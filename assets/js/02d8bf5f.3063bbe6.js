"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[9704],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}},44086:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"big-data/Apache Kafka/concepts","title":"Concepts","description":"- Partitions of topic can be stored in different servers (scaled horizontally)","source":"@site/docs/big-data/Apache Kafka/concepts.md","sourceDirName":"big-data/Apache Kafka","slug":"/big-data/Apache Kafka/concepts","permalink":"/Docs/docs/next/big-data/Apache Kafka/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/big-data/Apache Kafka/concepts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"bigdataSidebar","previous":{"title":"ACLs","permalink":"/Docs/docs/next/big-data/Apache Kafka/acls"},"next":{"title":"Kafka Connect","permalink":"/Docs/docs/next/big-data/Apache Kafka/connect/"}}');var r=s(74848),t=s(28453);const o={},l="Concepts",c={},a=[{value:"Broker",id:"broker",level:2},{value:"Controller",id:"controller",level:2},{value:"Leader",id:"leader",level:2},{value:"Partition",id:"partition",level:2},{value:"Retention",id:"retention",level:2},{value:"Consumer",id:"consumer",level:2},{value:"Partition reassignment",id:"partition-reassignment",level:3},{value:"Configuration parameters",id:"configuration-parameters",level:3},{value:"Offset commit",id:"offset-commit",level:3},{value:"Producer",id:"producer",level:2},{value:"Consuming strategies",id:"consuming-strategies",level:2},{value:"Links",id:"links",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Partitions of topic can be stored in different servers (scaled horizontally)"}),"\n",(0,r.jsx)(n.li,{children:"Consumer read a message in order they arrive"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"broker",children:"Broker"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Knows all about topics and partitions metadata"}),"\n",(0,r.jsx)(n.li,{children:"Is bootstrap broker"}),"\n",(0,r.jsx)(n.li,{children:"Stores some topics and partitions"}),"\n",(0,r.jsx)(n.li,{children:"Receive messages from Producer"}),"\n",(0,r.jsx)(n.li,{children:"Assign offsets to messages"}),"\n",(0,r.jsx)(n.li,{children:"Commit messages to disk"}),"\n",(0,r.jsx)(n.li,{children:"Responds to consumers with messages"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"controller",children:"Controller"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Elected automatically"}),"\n",(0,r.jsx)(n.li,{children:"Responsible for administrative operations (Assign partitions to brokers and monitoring for broker failures)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"leader",children:"Leader"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The owner of partition"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"partition",children:"Partition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can not be deleted once is created"}),"\n",(0,r.jsx)(n.li,{children:"Order is guaranteed within the partition, and once data is wrote to partition is immutable"}),"\n",(0,r.jsxs)(n.li,{children:["Key used:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"As additional information that gets stored with the message"}),"\n",(0,r.jsx)(n.li,{children:"To decide to which one of the topic partitions the message will be writen to. All the message with the same key\r\nwill go to same partition"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"retention",children:"Retention"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can be the number of days"}),"\n",(0,r.jsx)(n.li,{children:"Or when topic reaches certain size in bytes"}),"\n",(0,r.jsx)(n.li,{children:"Individual topic can have its own retention"}),"\n",(0,r.jsxs)(n.li,{children:["Topic can also be configured with ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"log compacted"})})," that means Kafka will retain only ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"the last"})})," messages with some keys"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consumer",children:"Consumer"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The way to scale data consumption is by adding more consumer to consumer group"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coordinator group:"})," broker responsible to manage consumer of consumer group","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To join coordinator group, the consumer sends ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"JoinGroup"})})," request"]}),"\n",(0,r.jsxs)(n.li,{children:["The first consumer who joined the group become the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"leader"})})," of the group"]}),"\n",(0,r.jsx)(n.li,{children:"The leader is responsible to assign partitions to consumer"}),"\n",(0,r.jsxs)(n.li,{children:["Leader uses ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Range"})})," or ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"RoundRobin"})})," policy to assign partition to the consumer"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"KafkaConsumer is not thread safe, it needs to be executed in one thread"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"partition-reassignment",children:"Partition reassignment"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It happens when","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New consumer is added to consumer group"}),"\n",(0,r.jsx)(n.li,{children:"Consumer shuts down or crashes"}),"\n",(0,r.jsx)(n.li,{children:"The topics the consumers are consuming is modified (e.g. administrator add new partition to topic)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"During re-balance a consumer cannot consume, they should wait until re-balance is finished"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"configuration-parameters",children:"Configuration parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"auto.offset.reset"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"latest:"})," is the default (records written after consumer were started)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"earliest:"})," read the data starting from the very beginning"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"none"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"enable.auto.commit"}),": can be true or false. Allows Kafka to commit automatically the offset it had consumed"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"offset-commit",children:"Offset commit"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Kafka does not track acknowledgments from consumers the way many JMS queues do"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"It allows consumers to use Kafka to track their position (offset) in each partition"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Consumer commit offset by producing a message to Kafka to topic ",(0,r.jsx)(n.strong,{children:"__consumer_offsets"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Commit type"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto commit:"})," ",(0,r.jsx)(n.code,{children:"enable.auto.commit=true"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync commit:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"commitSync()"})," API commit the last offset return by the ",(0,r.jsx)(n.code,{children:"poll()"})," and throws an exception ",(0,r.jsx)(n.code,{children:"CommitedFailException"})," if the commit fails for some reason"]}),"\n",(0,r.jsxs)(n.li,{children:["Drawback:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It blocks until the broker responds to the commit request"}),"\n",(0,r.jsx)(n.li,{children:"Will retry until the commit succeeded or encounter  non-retriable error"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async commit:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"commitSync()"})," API  sends request and continue, don't wait for the broker response"]}),"\n",(0,r.jsx)(n.li,{children:"It does not retry"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"subscribe()"}),": leverage consumer group mechanism"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"assign()"}),": used to assign partitions manually to consumer"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"subscribe"})," and ",(0,r.jsx)(n.strong,{children:"assign"})," can't  be called by the same confuser"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"close()"}),": on consumer immediately triggers a partition re-balance as the consumer will not be available anymore"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"producer",children:"Producer"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"KafkaProducer is thread safe"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consuming-strategies",children:"Consuming strategies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"At-most-once:"})," never duplicate messages, but can miss ones"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"At-last-once:"})," can duplicate messages but can't miss ones"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exactly-once:"})," deliver all messages without duplication"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"http://lahotisolutions.blogspot.com/2019/03/apache-kafka-notes.html",children:"http://lahotisolutions.blogspot.com/2019/03/apache-kafka-notes.html"})}),"\n",(0,r.jsx)(n.p,{children:"livelock : application did not crash but fails to make progress for some reason"})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);