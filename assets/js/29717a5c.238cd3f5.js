"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[8512],{28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var n=i(96540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},83659:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"big-data/Apache Iceberg/optimization","title":"Optimization","description":"- Reducing the number of data files","source":"@site/docs/big-data/Apache Iceberg/optimization.md","sourceDirName":"big-data/Apache Iceberg","slug":"/big-data/Apache Iceberg/optimization","permalink":"/Docs/docs/next/big-data/Apache Iceberg/optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/big-data/Apache Iceberg/optimization.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"bigdataSidebar","previous":{"title":"Apache Iceberg Architecture","permalink":"/Docs/docs/next/big-data/Apache Iceberg/architecture"},"next":{"title":"Apache Iceberg Features","permalink":"/Docs/docs/next/big-data/Apache Iceberg/features/"}}');var a=i(74848),r=i(28453);const o={sidebar_position:2},s="Optimization",l={},d=[{value:"Compaction",id:"compaction",level:2},{value:"Sorting",id:"sorting",level:2},{value:"Partition",id:"partition",level:2},{value:"Patition Evolition",id:"patition-evolition",level:3},{value:"Metric Collection",id:"metric-collection",level:2},{value:"Copy-On-Write and Merge-On-Read",id:"copy-on-write-and-merge-on-read",level:2},{value:"Copy-On-Write",id:"copy-on-write",level:3},{value:"Rewrite Manifest Files",id:"rewrite-manifest-files",level:2},{value:"Storage Optimization",id:"storage-optimization",level:2},{value:"Expire Snapshots",id:"expire-snapshots",level:3},{value:"Remove Orphan Files",id:"remove-orphan-files",level:3},{value:"Write distribution mode",id:"write-distribution-mode",level:2},{value:"Object Storage",id:"object-storage",level:2}];function c(e){const t={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"optimization",children:"Optimization"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Reducing the number of data files"}),"\n",(0,a.jsx)(t.li,{children:"Data sorting"}),"\n",(0,a.jsx)(t.li,{children:"Table partitionning"}),"\n",(0,a.jsx)(t.li,{children:"Row-level update handling"}),"\n",(0,a.jsx)(t.li,{children:"Metric collection"}),"\n",(0,a.jsx)(t.li,{children:"External factors"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"compaction",children:"Compaction"}),"\n",(0,a.jsxs)(t.p,{children:["Each operation on file genererate metadata file this can lead to small files problem, espcially when dealing with stream. When you querying iceberg table you need to open and and scan each file and close the file you'are done. The more files you have to scan for a query, the greater the cost\r\nthese file operations will put on your query.",(0,a.jsx)(t.br,{}),"\n","The solution is to periodically take the data in the all small files and rewrite it into a lager files (you may also want to rewrite manifests if there are too many manifests relative to the number of datafiles you have). This process is called compation"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["In Spark the compaction is performed using the method: ",(0,a.jsx)(t.strong,{children:"reweriteDataFiles"})]}),"\n",(0,a.jsxs)(t.li,{children:["Methods:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"binPack"}),"\n",(0,a.jsx)(t.li,{children:"Sort"}),"\n",(0,a.jsx)(t.li,{children:"zOrder"}),"\n",(0,a.jsx)(t.li,{children:"filter"}),"\n",(0,a.jsx)(t.li,{children:"option"}),"\n",(0,a.jsx)(t.li,{children:"options"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"sorting",children:"Sorting"}),"\n",(0,a.jsx)(t.p,{children:"Helps limit the number of files that needed to be  scanned to get the data needed by the query. Sorting the data allows the data with similar values to be concentrated into fewer files, allowing for more efficient query planning"}),"\n",(0,a.jsx)(t.h2,{id:"partition",children:"Partition"}),"\n",(0,a.jsx)(t.p,{children:"When a table is partitioned, instead of just sorting the order based on a field, it will write records with distinct values of the target field into their own datafiles."}),"\n",(0,a.jsx)(t.h3,{id:"patition-evolition",children:"Patition Evolition"}),"\n",(0,a.jsx)(t.p,{children:"Changing how the the table was  partitioned required you to rewrite the entire table.\r\nMetadata-tracked partitioning: the metadata tracks not only partition values but also historical partition schemes, allowing the partition schemes to evolve."}),"\n",(0,a.jsx)(t.h2,{id:"metric-collection",children:"Metric Collection"}),"\n",(0,a.jsx)(t.p,{children:"You can specify the metric you want to collect"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"option"}),(0,a.jsx)(t.th,{children:"meaning"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"none"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"counts"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"truncate"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"full"}),(0,a.jsx)(t.td,{})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"copy-on-write-and-merge-on-read",children:"Copy-On-Write and Merge-On-Read"}),"\n",(0,a.jsx)(t.h3,{id:"copy-on-write",children:"Copy-On-Write"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Every update in create a new datafile and the the new datafile replace the old one in a new snapshot"}),"\n",(0,a.jsx)(t.li,{children:"Ideal to optimize reads because the query don't need to reconcile deleted pr updated file"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"rewrite-manifest-files",children:"Rewrite Manifest Files"}),"\n",(0,a.jsx)(t.p,{children:"When a table accumulates many snapshots over time, it can also accumulate a large number of lightweight manifest files.\r\nDuring reads and writes, Iceberg must scan these manifests to discover which data files are relevant, and having too many manifests increases the amount of metadata operations required."}),"\n",(0,a.jsx)(t.p,{children:"The rewrite_manifest procedure optimizes this metadata layout by rewriting and regrouping manifest files, producing fewer, larger manifest files that each reference more data files.\r\nThis improves query planning performance and reduces metadata overhead."}),"\n",(0,a.jsx)(t.p,{children:"When running this procedure with Spark, be aware that Spark may attempt to cache metadata files in memory, which can lead to memory pressure on large tables.\r\nIf necessary, you can disable Spark caching to avoid excessive memory consumption during the manifest rewrite operation."}),"\n",(0,a.jsx)(t.h2,{id:"storage-optimization",children:"Storage Optimization"}),"\n",(0,a.jsx)(t.h3,{id:"expire-snapshots",children:"Expire Snapshots"}),"\n",(0,a.jsx)(t.p,{children:"Updates and compactions often generate files that are no longer needed, because these files remain associated with historical snapshots of the table.\r\nTo avoid storing unnecessary data and reduce storage costs, you should periodically expire old snapshots, which removes data and metadata files that are no longer referenced by the current table state."}),"\n",(0,a.jsx)(t.p,{children:"This operation helps keep the metadata tree small and ensures that Iceberg only retains the files required for the retention window you have configured."}),"\n",(0,a.jsx)(t.h3,{id:"remove-orphan-files",children:"Remove Orphan Files"}),"\n",(0,a.jsx)(t.p,{children:"Orphaned data files are data files that are no longer referenced by any Iceberg table metadata. They can appear after task or job failures, or even during normal snapshot expiration when the process does not successfully delete all data files that are no longer referenced by the remaining snapshots."}),"\n",(0,a.jsx)(t.p,{children:"Importantly, expiring snapshots does not clean up orphan files, because Iceberg never referenced these files to begin with.\r\nTherefore, you should periodically run a dedicated maintenance operation to remove them."}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"remove_orphan_files"})," procedure scans all files under the table\u2019s location and determines whether each file is referenced by any active snapshot.\r\nFiles that are not referenced are considered orphaned and are safely deleted."]}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"remove_orphan_files"})," operation is intensive, as it must scan the entire table directory.\r\nIt should be executed sparingly, ideally during low-traffic maintenance windows."]})}),"\n",(0,a.jsx)(t.h2,{id:"write-distribution-mode",children:"Write distribution mode"}),"\n",(0,a.jsx)(t.h2,{id:"object-storage",children:"Object Storage"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);