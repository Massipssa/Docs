"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[8512],{28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var n=i(96540);const a={},o=n.createContext(a);function r(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(o.Provider,{value:t},e.children)}},83659:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"big-data/Apache Iceberg/optimization","title":"Optimization","description":"- Reducing the number of data files","source":"@site/docs/big-data/Apache Iceberg/optimization.md","sourceDirName":"big-data/Apache Iceberg","slug":"/big-data/Apache Iceberg/optimization","permalink":"/Docs/docs/next/big-data/Apache Iceberg/optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/big-data/Apache Iceberg/optimization.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"bigdataSidebar","previous":{"title":"Apache Iceberg Architecture","permalink":"/Docs/docs/next/big-data/Apache Iceberg/architecture"},"next":{"title":"Reading and Writing in Apache Iceberg","permalink":"/Docs/docs/next/big-data/Apache Iceberg/read-write"}}');var a=i(74848),o=i(28453);const r={sidebar_position:2},s="Optimization",l={},c=[{value:"Compaction",id:"compaction",level:2},{value:"Partition",id:"partition",level:2},{value:"Patition Evolition",id:"patition-evolition",level:3}];function d(e){const t={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"optimization",children:"Optimization"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Reducing the number of data files"}),"\n",(0,a.jsx)(t.li,{children:"Data sorting"}),"\n",(0,a.jsx)(t.li,{children:"Table partitionning"}),"\n",(0,a.jsx)(t.li,{children:"Row-level update handling"}),"\n",(0,a.jsx)(t.li,{children:"Metric collection"}),"\n",(0,a.jsx)(t.li,{children:"External factors"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"compaction",children:"Compaction"}),"\n",(0,a.jsx)(t.p,{children:"Each operation on file genererate metadata file this can lead to small files problem, espcially when delaing with stream.\r\nThe solution is to periodically take the data in the all small files and rewrite it into a lager files (you may also want to rewrite manifests if there are too many manifests relative to the number of datafiles you have). This process is calle compation"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"In Spark the compaction is performed using the method: reweriteDataFiles:"}),"\n",(0,a.jsxs)(t.li,{children:["Methods:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"binPack"}),"\n",(0,a.jsx)(t.li,{children:"Sort"}),"\n",(0,a.jsx)(t.li,{children:"zOrder"}),"\n",(0,a.jsx)(t.li,{children:"filter"}),"\n",(0,a.jsx)(t.li,{children:"option"}),"\n",(0,a.jsx)(t.li,{children:"options"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"partition",children:"Partition"}),"\n",(0,a.jsx)(t.p,{children:"When a table is partitioned, instead of just sorting the order based on a field, it will write records with distinct values of the target field into their own datafiles."}),"\n",(0,a.jsx)(t.h3,{id:"patition-evolition",children:"Patition Evolition"}),"\n",(0,a.jsx)(t.p,{children:"Changing how the the table was  partitioned required you to rewrite the entire table.\r\nMetadata-tracked partitioning: the metadata tracks not only partition values but also historical partition schemes, allowing the partition schemes to evolve."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);