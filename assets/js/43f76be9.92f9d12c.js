"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[299],{24494:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"big-data/Apache Iceberg/architecture","title":"Apache Iceberg Architecture","description":"Apache Iceberg is designed with a layered architecture to efficiently manage large analytic datasets, support schema evolution, and enable features like time travel and concurrent writes.","source":"@site/docs/big-data/Apache Iceberg/architecture.md","sourceDirName":"big-data/Apache Iceberg","slug":"/big-data/Apache Iceberg/architecture","permalink":"/Docs/docs/next/big-data/Apache Iceberg/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/big-data/Apache Iceberg/architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"bigdataSidebar","previous":{"title":"Concepts","permalink":"/Docs/docs/next/big-data/Apache Beam/concepts"},"next":{"title":"Optimization","permalink":"/Docs/docs/next/big-data/Apache Iceberg/optimization"}}');var r=a(74848),i=a(28453);const s={sidebar_position:1},l="Apache Iceberg Architecture",d={},c=[{value:"Layers Overview",id:"layers-overview",level:2},{value:"Catalog Layer",id:"catalog-layer",level:3},{value:"Metadata Layer",id:"metadata-layer",level:2},{value:"Manifest File",id:"manifest-file",level:3},{value:"Manifest List",id:"manifest-list",level:3},{value:"Metadata File",id:"metadata-file",level:3},{value:"Data Layer",id:"data-layer",level:2},{value:"Data Modification Approaches",id:"data-modification-approaches",level:3},{value:"Supported Delete Operations",id:"supported-delete-operations",level:4}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"apache-iceberg-architecture",children:"Apache Iceberg Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"Apache Iceberg is designed with a layered architecture to efficiently manage large analytic datasets, support schema evolution, and enable features like time travel and concurrent writes."}),"\n",(0,r.jsx)(n.h2,{id:"layers-overview",children:"Layers Overview"}),"\n",(0,r.jsx)(n.p,{children:"Iceberg consists of three main layers:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Catalog Layer"})," \u2013 Manages table locations and metadata pointers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metadata Layer"})," \u2013 Tracks table metadata, schema, partitioning, and file statistics."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Layer"})," \u2013 Stores the actual table data and delete information."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"iceberg-archi",src:a(91802).A+"",width:"793",height:"816"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"catalog-layer",children:"Catalog Layer"}),"\n",(0,r.jsxs)(n.p,{children:["The catalog layer maps fully qualified table names (namespace + table) to their current metadata file (",(0,r.jsx)(n.strong,{children:"metadata pointer"}),"). It ensures atomic updates to the metadata pointer, so all readers and writers see a consistent table state."]}),"\n",(0,r.jsx)(n.p,{children:"Depending on the catalog implementation, the metadata pointer is stored differently:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"S3:"})," Uses a file named ",(0,r.jsx)(n.code,{children:"version-hint.text"})," in the table\u2019s metadata folder, containing the current metadata file version."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AWS Glue:"})," Stores the pointer as a table property called ",(0,r.jsx)(n.code,{children:"metadata_location"}),", holding the full path to the current metadata file."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apache Hive:"})," Uses the ",(0,r.jsx)(n.code,{children:"location"})," table property to point to the current metadata file."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"metadata-layer",children:"Metadata Layer"}),"\n",(0,r.jsx)(n.p,{children:"The metadata layer contains all metadata files for an Iceberg table. It forms a tree structure that tracks data files, delete files, and the operations that created them. This layer is essential for efficient data management and enables features like time travel and schema evolution."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Three key file types:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#manifest-file",children:"Manifest files"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#manifest-list",children:"Manifest lists"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#metadata-file",children:"Metadata files"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"manifest-file",children:"Manifest File"}),"\n",(0,r.jsx)(n.p,{children:"Manifest files track data files and delete files, along with statistics such as minimum and maximum column values. These files are generated incrementally during writes, making statistics collection efficient compared to legacy formats like Hive."}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Separate manifest files track data files and delete files, but both use the same schema."}),"\n",(0,r.jsx)(n.li,{children:"Manifest files store statistics at write time, avoiding expensive full-table scans required by older formats."}),"\n",(0,r.jsx)(n.li,{children:"Query engines use manifest file statistics (e.g., upper/lower bounds, null counts, partition data) for file pruning, improving query performance."}),"\n"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\r\n  "manifest_path": "warehouse/db/persons/metadata/d9b53757-55a3-4f7e-80b6-926ce7edac4b-m0.avro",\r\n  "manifest_length": 6930,\r\n  "partition_spec_id": 0,\r\n  "content": 0,\r\n  "sequence_number": 1,\r\n  "min_sequence_number": 1,\r\n  "added_snapshot_id": 2093926769621697207,\r\n  "added_data_files_count": 1,\r\n  "existing_data_files_count": 0,\r\n  "deleted_data_files_count": 0,\r\n  "added_rows_count": 1,\r\n  "existing_rows_count": 0,\r\n  "deleted_rows_count": 0,\r\n  "partitions": {\r\n    "array": [\r\n      {\r\n        "contains_null": false,\r\n        "contains_nan": {\r\n          "boolean": false\r\n        },\r\n        "lower_bound": {\r\n          "bytes": "2\\u0000\\u0000\\u0000"\r\n        },\r\n        "upper_bound": {\r\n          "bytes": "2\\u0000\\u0000\\u0000"\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manifest-list",children:"Manifest List"}),"\n",(0,r.jsx)(n.p,{children:"A manifest list captures the state of an Iceberg table at a specific point in time. It contains a list of manifest files, each describing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data file locations"}),"\n",(0,r.jsx)(n.li,{children:"Partition information"}),"\n",(0,r.jsx)(n.li,{children:"Upper and lower bounds of partition columns"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Query engines use manifest lists to evaluate partition specs and skip irrelevant files, enabling fast, efficient reads."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\r\n  "status": 1,\r\n  "snapshot_id": {\r\n    "long": 2093926769621697207\r\n  },\r\n  "sequence_number": null,\r\n  "file_sequence_number": null,\r\n  "data_file": {\r\n    "content": 0,\r\n    "file_path": "warehouse/db/persons/data/age=50/00000-1-a3af8354-0914-4e6f-a7a6-82c980a4cfc1-00001.parquet",\r\n    "file_format": "PARQUET",\r\n    "partition": {\r\n      "age": {\r\n        "int": 50\r\n      }\r\n    },\r\n    "record_count": 1,\r\n    "file_size_in_bytes": 907,\r\n    "column_sizes": {\r\n      "array": [\r\n        {\r\n          "key": 1,\r\n          "value": 43\r\n        },\r\n        {\r\n          "key": 2,\r\n          "value": 36\r\n        },\r\n        {\r\n          "key": 3,\r\n          "value": 43\r\n        }\r\n      ]\r\n    },\r\n    "value_counts": {\r\n      "array": [\r\n        {\r\n          "key": 1,\r\n          "value": 1\r\n        },\r\n        {\r\n          "key": 2,\r\n          "value": 1\r\n        },\r\n        {\r\n          "key": 3,\r\n          "value": 1\r\n        }\r\n      ]\r\n    },\r\n    "null_value_counts": {\r\n      "array": [\r\n        {\r\n          "key": 1,\r\n          "value": 0\r\n        },\r\n        {\r\n          "key": 2,\r\n          "value": 0\r\n        },\r\n        {\r\n          "key": 3,\r\n          "value": 0\r\n        }\r\n      ]\r\n    },\r\n    "nan_value_counts": {\r\n      "array": []\r\n    },\r\n    "lower_bounds": {\r\n      "array": [\r\n        {\r\n          "key": 1,\r\n          "value": "Charlie"\r\n        },\r\n        {\r\n          "key": 2,\r\n          "value": "2\\u0000\\u0000\\u0000"\r\n        },\r\n        {\r\n          "key": 3,\r\n          "value": "Teacher"\r\n        }\r\n      ]\r\n    },\r\n    "upper_bounds": {\r\n      "array": [\r\n        {\r\n          "key": 1,\r\n          "value": "Charlie"\r\n        },\r\n        {\r\n          "key": 2,\r\n          "value": "2\\u0000\\u0000\\u0000"\r\n        },\r\n        {\r\n          "key": 3,\r\n          "value": "Teacher"\r\n        }\r\n      ]\r\n    },\r\n    "key_metadata": null,\r\n    "split_offsets": {\r\n      "array": [\r\n        4\r\n      ]\r\n    },\r\n    "equality_ids": null,\r\n    "sort_order_id": {\r\n      "int": 0\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"metadata-file",children:"Metadata File"}),"\n",(0,r.jsx)(n.p,{children:"The metadata file tracks manifest lists and contains the table\u2019s schema, partitioning details, snapshots, and the identifier of the current snapshot. Each table modification creates a new metadata file, registered as the latest version."}),"\n",(0,r.jsx)(n.p,{children:"This design supports:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent writes:"})," Multiple engines can write data simultaneously without conflict."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistent reads:"})," Readers always access the latest committed version of the table."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"data-layer",children:"Data Layer"}),"\n",(0,r.jsxs)(n.p,{children:["The data layer holds the actual table data, consisting of ",(0,r.jsx)(n.strong,{children:"data files"})," and ",(0,r.jsx)(n.strong,{children:"delete files"}),". It is typically backed by distributed storage systems such as HDFS, Amazon S3, Google Cloud Storage (GCS), Azure Data Lake Storage (ADLS), and others."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Files:"})," Store the actual table data. Supported formats include Apache Parquet, Apache Avro, and Apache ORC."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Delete Files:"})," Track rows deleted from the dataset without rewriting underlying data files, enabling efficient deletes."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Data in a data lake should be immutable. Updates are handled by writing new files rather than modifying existing ones."})}),"\n",(0,r.jsx)(n.h3,{id:"data-modification-approaches",children:"Data Modification Approaches"}),"\n",(0,r.jsx)(n.p,{children:"Apache Iceberg supports two approaches for handling data changes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Copy-On-Write (COW):"})," Changes are applied by creating a new version of the data file with updates. The old file is replaced."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Merge-On-Read (MOR):"})," Changes (inserts, updates, deletes) are written to separate delta or delete files. Query engines merge these changes with base data at read time."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"supported-delete-operations",children:"Supported Delete Operations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"MOR delete methods"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Positional delete files"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Equality delete files"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Iceberg\u2019s layered architecture enables scalable, reliable, and flexible data lake management, supporting advanced analytics and evolving business requirements."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>l});var t=a(96540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},91802:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/00-layers-bea8deadc8f4805ef69a2a3e3f15828e.png"}}]);