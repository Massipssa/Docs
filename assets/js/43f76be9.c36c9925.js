"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[299],{4494:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"big-data/Apache Iceberg/architecture","title":"Apache Iceberg Architecture","description":"Layers","source":"@site/docs/big-data/Apache Iceberg/architecture.md","sourceDirName":"big-data/Apache Iceberg","slug":"/big-data/Apache Iceberg/architecture","permalink":"/Docs/docs/big-data/Apache Iceberg/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/big-data/Apache Iceberg/architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"bigdataSidebar","previous":{"title":"Concepts","permalink":"/Docs/docs/big-data/Apache Beam/concepts"},"next":{"title":"Optimization","permalink":"/Docs/docs/big-data/Apache Iceberg/optimization"}}');var i=a(4848),s=a(8453);const r={sidebar_position:1},l="Apache Iceberg Architecture",d={},c=[{value:"Layers",id:"layers",level:2},{value:"Catalog Layer",id:"catalog-layer",level:3},{value:"Metadata Layer",id:"metadata-layer",level:2},{value:"Manifest file",id:"manifest-file",level:3},{value:"Manifest list",id:"manifest-list",level:3},{value:"Metadata file",id:"metadata-file",level:3},{value:"Data Layer",id:"data-layer",level:2}];function o(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"apache-iceberg-architecture",children:"Apache Iceberg Architecture"})}),"\n",(0,i.jsx)(t.h2,{id:"layers",children:"Layers"}),"\n",(0,i.jsx)(t.p,{children:"Apache iceberg is made up by a three layer"}),"\n",(0,i.jsx)(t.h3,{id:"catalog-layer",children:"Catalog Layer"}),"\n",(0,i.jsxs)(t.p,{children:["A catalog maps fully qualified table names (namespace + table) to their current metadata file (",(0,i.jsx)(t.strong,{children:"metadata pointer"}),").\r\nIt must support atomic updates to the metadata pointer, ensuring that all readers and writers see a consistent table\r\nstate at any given time."]}),"\n",(0,i.jsx)(t.p,{children:"Depending on the catalog in use, the metadata pointer is stored differently. For example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"S3"})," Catalog stores the pointer in a file named ",(0,i.jsx)(t.strong,{children:"version-hint.text"})," within the table\u2019s metadata folder. This file\r\ncontains the version number of the current metadata file."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"AWS Glue"})," stores the pointer as a table property called ",(0,i.jsx)(t.strong,{children:"metadata_location"}),", which holds the full path to the\r\ncurrent metadata file."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Apache Hive"})," uses the ",(0,i.jsx)(t.strong,{children:"location"})," table property to point to the current metadata file."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"metadata-layer",children:"Metadata Layer"}),"\n",(0,i.jsx)(t.p,{children:"It's a layer that contains all metadata files for a table in Iceberg. It's a tree that tracks the datafiles and\r\nmetadata about them as well as the operations that resulted in the creation. It's made up of three file types:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#manifest-file",children:"Manifest files"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#manifest-list-",children:"Manifest lists"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#metadata-file-",children:"Metadata files"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This layer is essential for efficiently managing large datasets and enable core features such as time travel and schema evolution.\xa0"}),"\n",(0,i.jsx)(t.h3,{id:"manifest-file",children:"Manifest file"}),"\n",(0,i.jsx)(t.p,{children:"keep track of file in the data layer (datafiles and delete files) as well as some additional details\r\nand statistics about each file such as minimum and maximum values of datafile's columns."}),"\n",(0,i.jsx)(t.p,{children:"!!! note"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Separate subset of manifest files are used to track datafiles and delete file but the schema is identical same\r\nfor both."}),"\n",(0,i.jsx)(t.li,{children:"During writes, the engine generates statistics and stores them in manifest files that track small batches of data\r\nfiles. Because these stats are recorded incrementally at write time, producing them is far lighter than in the Hive\r\ntable format, where statistics are gathered by long, expensive read jobs that must scan entire partitions\u2014or even\r\nwhole tables\u2014before writing partition- or table-level stats."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Information from the manifest files, such as upper and lower bounds for a specific column, null value counts,\r\nand partition-specific data, is used by the engine for file pruning."}),"\n",(0,i.jsx)(t.h3,{id:"manifest-list",children:"Manifest list"}),"\n",(0,i.jsx)(t.p,{children:"A manifest list captures the state of an Iceberg table at a specific point in time. It contains a list of manifest files, each describing:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The location of data files"}),"\n",(0,i.jsx)(t.li,{children:"The partitions they belong to"}),"\n",(0,i.jsx)(t.li,{children:"The upper and lower bounds of partition columns"}),"\n",(0,i.jsx)(t.li,{children:"..."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Query engines use this information to evaluate partition specs and skip irrelevant manifest files, enabling faster,\r\nmore efficient reads through data pruning."}),"\n",(0,i.jsx)(t.h3,{id:"metadata-file",children:"Metadata file"}),"\n",(0,i.jsx)(t.p,{children:"The metadata file tracks manifest list files and contains the table\u2019s schema, partitioning details, snapshots,\r\nand the identifier of the current snapshot. Each time an Iceberg table is modified, a new metadata file is created and\r\nregistered as the latest version. This design supports critical scenarios such as:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Concurrent writes"})," \u2013 allowing multiple engines to write data simultaneously without conflict."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Consistent reads"})," \u2013 ensuring that readers always access the latest committed version of the table."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"data-layer",children:"Data Layer"}),"\n",(0,i.jsxs)(t.p,{children:["The data layer in an Apache Iceberg table holds the actual table data, primarily made up of ",(0,i.jsx)(t.strong,{children:"data files"})," and\r\n",(0,i.jsx)(t.strong,{children:"delete files"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This layer is responsible for serving query results\u2014unless a query can be resolved using metadata\r\nalone (e.g., min/max value lookups). In Iceberg\u2019s tree-like architecture, the data layer represents the leaf nodes."}),"\n",(0,i.jsx)(t.p,{children:"It is typically backed by distributed storage systems such as HDFS, Amazon S3, Google Cloud Storage (GCS),\r\nAzure Data Lake Storage (ADLS), and others."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Data Files"}),"\r\nThese files store the actual table data. As of now, Iceberg supports three file formats: Apache Parquet, Apache Avro,\r\nand Apache ORC."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Delete Files"}),"\r\nThese track rows that have been deleted from the dataset without rewriting the underlying data files,\r\nenabling efficient handling of deletes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"!!! info\r\nIt's a best practice to keep data in data lake immutable, so you can't update rows in file in place. Instead,\r\nyou need to write a new file."}),"\n",(0,i.jsx)(t.p,{children:"Apache Iceberg supports two approaches for handling data modifications:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Copy-On-Write (COW):"})," Changes are written by creating a new version of the data file with all updates applied.\r\nThe old file is replaced by this updated copy."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Merge-On-Read (MOR):"})," Only the changes (inserts, updates, deletes) are written to separate delta or delete files.\r\nQuery engines merge these changes with the base data at read time."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supported deletes operations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"MOR delete methods"}),"\n",(0,i.jsx)(t.li,{children:"Positional delete file"}),"\n",(0,i.jsx)(t.li,{children:"Equality delete file"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>l});var n=a(6540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);