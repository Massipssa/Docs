"use strict";(self.webpackChunktestdoc=self.webpackChunktestdoc||[]).push([[980],{5883:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"programming/Principals/SOLID","title":"SOLID","description":"- When not applied","source":"@site/docs/programming/Principals/SOLID.md","sourceDirName":"programming/Principals","slug":"/programming/Principals/SOLID","permalink":"/Docs/docs/next/programming/Principals/SOLID","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/programming/Principals/SOLID.md","tags":[],"version":"current","frontMatter":{},"sidebar":"programmingSidebar","previous":{"title":"KISS","permalink":"/Docs/docs/next/programming/Principals/KISS"},"next":{"title":"YAGNI","permalink":"/Docs/docs/next/programming/Principals/YAGNI"}}');var l=i(74848),t=i(28453);const r={},c="SOLID",o={},a=[{value:"Single Responsibility Principal (SRP)",id:"single-responsibility-principal-srp",level:2},{value:"Open Closed Principal (OCP)",id:"open-closed-principal-ocp",level:2},{value:"Liskov Substitution Principal (LSP)",id:"liskov-substitution-principal-lsp",level:2},{value:"Interface Segregation Principal (ISP)",id:"interface-segregation-principal-isp",level:2},{value:"Dependency Inversion Principal (DIP)",id:"dependency-inversion-principal-dip",level:2},{value:"Other best practices",id:"other-best-practices",level:2}];function d(e){const n={admonition:"admonition",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"solid",children:"SOLID"})}),"\n",(0,l.jsx)(n.admonition,{title:"warning",type:"danger",children:(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["When not applied","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Code fragility:"})," change in one module may create bugs in other modules"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Code rigidity:"})," change in one place will imply change in other places"]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,l.jsx)(n.h2,{id:"single-responsibility-principal-srp",children:"Single Responsibility Principal (SRP)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Every method, class or module should have only one and only one reason to change"}),"\n",(0,l.jsxs)(n.li,{children:["Pros","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Class less coupled and resilient for change"}),"\n",(0,l.jsx)(n.li,{children:"Make code more testable"}),"\n",(0,l.jsx)(n.li,{children:"Code easy to understand, fix and maintain"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["Identify the reason to change","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"if and else statement"}),"\n",(0,l.jsx)(n.li,{children:"switch cases"}),"\n",(0,l.jsx)(n.li,{children:"monster methods (long methods): identify the small responsibilities and put them in separates methods"}),"\n",(0,l.jsx)(n.li,{children:"God classes: classes with multiple responsibilities"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"open-closed-principal-ocp",children:"Open Closed Principal (OCP)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Closed for modification and Open for extension"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Pros:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"New feature can be added easily with minimal cost"}),"\n",(0,l.jsx)(n.li,{children:"Minimize the risk of creating regression bugs"}),"\n",(0,l.jsx)(n.li,{children:"Enforce the decoupling by isolating the changes in one specific component (Respects the SRP)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Who to do"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Inheritance (small drawback: create coupling between base class and derived class)"}),"\n",(0,l.jsx)(n.li,{children:"Strategy pattern"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"liskov-substitution-principal-lsp",children:"Liskov Substitution Principal (LSP)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"If S is subtype of T, then the objects of the type T in the program may be replaced by objects of type S\r\nwithout modifying the functionality of the program."}),"\n",(0,l.jsxs)(n.li,{children:["Every time when creating a relationship between object as the question ",(0,l.jsx)(n.em,{children:(0,l.jsx)(n.strong,{children:"Is substitutable by"})})]}),"\n",(0,l.jsx)(n.li,{children:"Example: Base class Bird, subclass Ostrich but an Ostrich can't fly"}),"\n",(0,l.jsxs)(n.li,{children:["Pros","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Eliminates incorrect relationship between objects"}),"\n",(0,l.jsxs)(n.li,{children:["Use ",(0,l.jsx)(n.em,{children:(0,l.jsx)(n.strong,{children:"Tell, don't ask!"})})," principal to eliminate type checking and casting"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["How to apply","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Make sure that a derived type can substitute its base type completely"}),"\n",(0,l.jsx)(n.li,{children:"Keep base class small and focus"}),"\n",(0,l.jsx)(n.li,{children:"Keep interfaces lean"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"interface-segregation-principal-isp",children:"Interface Segregation Principal (ISP)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Client shouldn't be forced to depend on the methods they do not use"}),"\n",(0,l.jsxs)(n.li,{children:["How to identify flat interface","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Interface with multiple methods"}),"\n",(0,l.jsx)(n.li,{children:"Interface with Low Cohesion (method that doesn't fit with the purpose of the interface)"}),"\n",(0,l.jsx)(n.li,{children:"Client that throws exception instead implementing method"}),"\n",(0,l.jsx)(n.li,{children:"Client provides empty implementation"}),"\n",(0,l.jsx)(n.li,{children:"Client forces implementation and becomes highly coupled"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"dependency-inversion-principal-dip",children:"Dependency Inversion Principal (DIP)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"High level module should not depend on low level model, both should depend on abstraction"}),"\n",(0,l.jsx)(n.li,{children:"Dependency Inversion, Dependency injection and Inversion of Control are combined to perform DIP"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"other-best-practices",children:"Other best practices"}),"\n",(0,l.jsx)(n.admonition,{type:"info",children:(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Constant refactoring"}),"\n",(0,l.jsx)(n.li,{children:"Design patterns"}),"\n",(0,l.jsx)(n.li,{children:"Unit testing (TDD, BDD)"}),"\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(96540);const l={},t=s.createContext(l);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);