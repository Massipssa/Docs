trait S3Service {
  def uploadMultipart(key: String, input: InputStream, partSize: Int): CompleteMultipartUploadResult
  def listAllKeys(prefix: String): List[S3ObjectSummary]
  def extractFilenameFromKey(objectKey: String): Option[String]
  def buildKey(parts: List[String], filename: String): String
  def splitKey(key: String): List[String]
  def containsKeyPart(key: String, part: String): Boolean
  def delete(key: String): Unit
}

class AwsS3Service(s3Client: AmazonS3, bucketName: String) extends S3Service {

  private val delimiter = "/"

  override def uploadMultipart(key: String, input: InputStream, partSize: Int): CompleteMultipartUploadResult = {
    val uploadId = s3Client.initiateMultipartUpload(new InitiateMultipartUploadRequest(bucketName, key)).getUploadId
    val buffer = new Array[Byte](partSize)

    def readStream(stream: InputStream): LazyList[(Int, Array[Byte])] = {
      val bytes = new Array[Byte](partSize)
      val read = stream.read(bytes)
      if (read == -1) LazyList.empty
      else (read, bytes.take(read)) #:: readStream(stream)
    }

    val partETags = readStream(input).zipWithIndex.map { case ((read, chunk), idx) =>
      val partStream = new ByteArrayInputStream(chunk)
      val partRequest = new UploadPartRequest()
        .withBucketName(bucketName)
        .withKey(key)
        .withUploadId(uploadId)
        .withPartNumber(idx + 1)
        .withInputStream(partStream)
        .withPartSize(read)

      val result = s3Client.uploadPart(partRequest)
      new PartETag(result.getPartNumber, result.getETag)
    }.toList.asJava

    s3Client.completeMultipartUpload(new CompleteMultipartUploadRequest(bucketName, key, uploadId, partETags))
  }

  override def listAllKeys(prefix: String): List[S3ObjectSummary] = {
    val req = new ListObjectsV2Request().withBucketName(bucketName).withPrefix(prefix)

    @tailrec
    def paginate(token: String, acc: List[S3ObjectSummary]): List[S3ObjectSummary] = {
      if (token != null) req.setContinuationToken(token)
      val result = s3Client.listObjectsV2(req)
      val newSummaries = result.getObjectSummaries.asScala.toList
      if (result.isTruncated) paginate(result.getNextContinuationToken, acc ++ newSummaries)
      else acc ++ newSummaries
    }

    paginate(null, Nil)
  }

  override def extractFilenameFromKey(objectKey: String): Option[String] =
    Option(objectKey)
      .filter(_.nonEmpty)
      .map(_.split(delimiter))
      .flatMap(_.lastOption)

  override def buildKey(parts: List[String], filename: String): String =
    (parts :+ filename).mkString(delimiter)
}

class AwsS3Service(s3Client: AmazonS3, bucketName: String) extends S3Service {

  private val delimiter = "/"

  // Split key into parts using delimiter
  override def splitKey(key: String): List[String] = {
    Option(key)
      .filter(_.nonEmpty)
      .map(_.split(delimiter).toList)
      .getOrElse {
        logger.warn("Provided key is null or empty")
        List.empty
      }
  }

  // Check if part exists in S3 key
  override def containsKeyPart(key: String, part: String): Boolean = {
    splitKey(key).contains(part)
  }

  // Delete an object from S3
  override def delete(key: String): Unit = {
    if (Option(key).exists(_.nonEmpty)) {
      s3Client.deleteObject(bucketName, key)
      logger.info(s"Deleted object: $key from bucket: $bucketName")
    } else {
      logger.warn("Cannot delete object: key is null or empty")
    }
  }

  // Other methods...
}

class AwsS3ServiceTest extends AnyFlatSpec with Matchers with MockitoSugar {

  val mockS3Client = mock[AmazonS3]
  val service = new AwsS3Service(mockS3Client, "my-bucket")

  "splitKey" should "split a key into parts" in {
    service.splitKey("a/b/c.txt") shouldEqual List("a", "b", "c.txt")
  }

  it should "return empty for null or empty key" in {
    service.splitKey(null) shouldBe empty
    service.splitKey("") shouldBe empty
  }

  "containsKeyPart" should "return true if part exists" in {
    service.containsKeyPart("a/b/c.txt", "b") shouldBe true
  }

  it should "return false if part is missing" in {
    service.containsKeyPart("a/b/c.txt", "x") shouldBe false
  }

  "delete" should "call deleteObject when key is valid" in {
    service.delete("file.csv")
    verify(mockS3Client).deleteObject("my-bucket", "file.csv")
  }

  it should "not call deleteObject for empty key" in {
    service.delete("")
    service.delete(null)
    verify(mockS3Client, never).deleteObject(any[String], any[String])
  }
}


import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.mockito.Mockito._
import org.mockito.ArgumentMatchers._
import org.scalatestplus.mockito.MockitoSugar
import com.amazonaws.services.s3.model.{AmazonS3Exception, ObjectMetadata}
import com.amazonaws.services.s3.AmazonS3

class AwsS3ServiceTest extends AnyFlatSpec with Matchers with MockitoSugar {

  val mockS3Client: AmazonS3 = mock[AmazonS3]
  val bucketName = "my-test-bucket"
  val service = new AwsS3Service(mockS3Client, bucketName)

  "createS3Uri" should "return correct S3 URI for given key" in {
    val key = "folder/file.csv"
    val result = service.createS3Uri(key)
    result shouldEqual "s3://my-test-bucket/folder/file.csv"
  }

  "exist" should "return true when object metadata is found" in {
    when(mockS3Client.getObjectMetadata(bucketName, "existing-key"))
      .thenReturn(new ObjectMetadata())

    val exists = service.exist("existing-key")
    exists shouldBe true
  }

  it should "return false when object does not exist" in {
    val exception = new AmazonS3Exception("Not Found")
    when(mockS3Client.getObjectMetadata(bucketName, "missing-key"))
      .thenThrow(exception)

    val exists = service.exist("missing-key")
    exists shouldBe false
  }
}


class AwsS3Service(s3Client: AmazonS3) extends S3Service {

  override def listAllObjects(prefix: String)(implicit jobConfig: JobConfigDto): List[S3ObjectSummary] = {
    if (StringUtils.isEmpty(jobConfig.bucketName)) {
      logger.warn("Provided bucket name is null or empty")
      return List.empty
    }

    val request = new ListObjectsV2Request()
      .withBucketName(jobConfig.bucketName)
      .withPrefix(prefix)

    @tailrec
    def fetchAll(accumulated: List[S3ObjectSummary], token: String = null): List[S3ObjectSummary] = {
      if (token != null) request.setContinuationToken(token)

      val result = s3Client.listObjectsV2(request)
      val summaries = result.getObjectSummaries.asScala.toList
      val nextToken = result.getNextContinuationToken

      if (result.isTruncated && nextToken != null)
        fetchAll(accumulated ++ summaries, nextToken)
      else
        accumulated ++ summaries
    }

    fetchAll(Nil)
  }
}


