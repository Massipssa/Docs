import org.yaml.snakeyaml.{DumperOptions, Yaml}
import org.yaml.snakeyaml.nodes._
import org.yaml.snakeyaml.representer.Representer
import org.yaml.snakeyaml.DumperOptions.ScalarStyle

import java.util.{LinkedHashMap => JLinkedMap, ArrayList => JList, Map => JMap}

// =======================
//  Modèle Scala
// =======================

case class Property(
  name: String,
  logicalType: String,
  partitioned: Boolean = false,
  partitionKeyPosition: Option[Int] = None
)

case class CustomProperty(
  property: String,
  value: Any
)

case class Schema(
  name: String,
  customProperties: List[CustomProperty],
  properties: List[Property]
)

case class DataContract(
  kind: String,
  apiVersion: String,
  id: String,
  status: String,
  version: String,
  schema: List[Schema]
)

// =======================
//  Representer custom
// =======================

class ContractRepresenter(options: DumperOptions) extends Representer(options) {

  /**
   * On détecte UNIQUEMENT la map de type :
   * { "property": "storage_descriptor", "value": <Map> }
   * qui correspond à un élément de la liste customProperties.
   */
  private def isStorageDescriptorCustomPropMap(data: Any): Boolean =
    data match {
      case m: JMap[_, _] =>
        m.containsKey("property") &&
        "storage_descriptor" == String.valueOf(m.get("property")) &&
        m.containsKey("value") &&
        m.get("value").isInstanceOf[JMap[_, _]]
      case _ => false
    }

  /**
   * Représentation FLOW { ... } + guillemets
   * pour le contenu de "value" (storage_descriptor & sous-maps).
   * C'est elle qui produit :
   *
   *   {
   *     "input_format": "...",
   *     "output_format": "...",
   *     "ser_de_info":
   *       {
   *         "serialization_library": "...",
   *         "parameters": { "field.delim": ";" }
   *       }
   *   }
   */
  private def representFlowMapWithQuotes(m: JMap[_, _]): MappingNode = {
    val tuples = new JList[NodeTuple]()
    val it     = m.entrySet().iterator()

    while (it.hasNext) {
      val e = it.next()

      val keyNode = new ScalarNode(
        Tag.STR,
        String.valueOf(e.getKey),
        null,
        null,
        ScalarStyle.DOUBLE_QUOTED
      )

      val valueNode: Node = e.getValue match {
        case inner: JMap[_, _] =>
          // ser_de_info, parameters, etc. => FLOW aussi, récursif
          representFlowMapWithQuotes(inner)

        case s: String =>
          new ScalarNode(Tag.STR, s, null, null, ScalarStyle.DOUBLE_QUOTED)

        case other =>
          new ScalarNode(Tag.STR, String.valueOf(other), null, null, ScalarStyle.DOUBLE_QUOTED)
      }

      tuples.add(new NodeTuple(keyNode, valueNode))
    }

    new MappingNode(Tag.MAP, tuples, DumperOptions.FlowStyle.FLOW)
  }

  /**
   * Surcharge de representMapping :
   *  - pour la map {property: "storage_descriptor", value: ...}
   *    on force :
   *
   *      - property: "storage_descriptor"
   *        value:
   *          { ... }   (FLOW + quotes)
   *
   *  - sinon : comportement SnakeYAML normal
   */
  override def representMapping(tag: Tag,
                                mapping: JMap[_, _],
                                flowStyle: DumperOptions.FlowStyle): Node = {

    if (isStorageDescriptorCustomPropMap(mapping)) {
      val tuples = new JList[NodeTuple]()

      // ---- entry "property": "storage_descriptor"
      val propKeyNode = new ScalarNode(Tag.STR, "property", null, null, ScalarStyle.PLAIN)
      val propValNode = new ScalarNode(
        Tag.STR,
        String.valueOf(mapping.get("property")),
        null,
        null,
        ScalarStyle.DOUBLE_QUOTED
      )
      tuples.add(new NodeTuple(propKeyNode, propValNode))

      // ---- entry "value": { ... } (FLOW + quotes)
      val valueKeyNode = new ScalarNode(Tag.STR, "value", null, null, ScalarStyle.PLAIN)
      val valueMap     = mapping.get("value").asInstanceOf[JMap[_, _]]
      val valueNode    = representFlowMapWithQuotes(valueMap)
      tuples.add(new NodeTuple(valueKeyNode, valueNode))

      // cet élément de customProperties reste une map BLOCK
      return new MappingNode(tag, tuples, DumperOptions.FlowStyle.BLOCK)
    }

    // Toutes les autres maps : schema, properties, root, etc.
    super.representMapping(tag, mapping, flowStyle)
  }

  // ⚠️ IMPORTANT :
  // On NE surcharge PAS representScalar.
  // Avec defaultScalarStyle = PLAIN, SnakeYAML va écrire :
  //   partitioned: true
  //   partitionKeyPosition: 1
  // et pas 'true' ou '1'.
}

// =======================
//  Helpers Scala -> Java
// =======================

object YamlGenerator {

  private def linkedMap(entries: (String, Any)*): JLinkedMap[String, Any] = {
    val m = new JLinkedMap[String, Any]()
    entries.foreach { case (k, v) => m.put(k, v) }
    m
  }

  private def toCustomPropsList(props: List[CustomProperty]): JList[Any] = {
    val list = new JList[Any]()
    props.foreach { cp =>
      val m = new JLinkedMap[String, Any]()
      m.put("property", cp.property)
      m.put("value", cp.value)
      list.add(m)
    }
    list
  }

  private def toPropertiesList(props: List[Property]): JList[Any] = {
    val list = new JList[Any]()
    props.foreach { p =>
      val m = new JLinkedMap[String, Any]()
      m.put("name", p.name)
      m.put("logicalType", p.logicalType)
      if (p.partitioned) {
        // booléen Java => YAML sans quotes
        m.put("partitioned", java.lang.Boolean.TRUE)
      }
      p.partitionKeyPosition.foreach { pos =>
        // entier Java => YAML sans quotes
        m.put("partitionKeyPosition", Int.box(pos))
      }
      list.add(m)
    }
    list
  }

  private def toSchemaList(schemas: List[Schema]): JList[Any] = {
    val list = new JList[Any]()
    schemas.foreach { s =>
      val schemaMap = new JLinkedMap[String, Any]()
      schemaMap.put("name", s.name)
      schemaMap.put("customProperties", toCustomPropsList(s.customProperties))
      schemaMap.put("properties", toPropertiesList(s.properties))
      list.add(schemaMap)
    }
    list
  }

  // =======================
  //  main
  // =======================

  def main(args: Array[String]): Unit = {

    // ----- construction du storage_descriptor -----

    val serDeParams: JLinkedMap[String, Any] = linkedMap(
      "field.delim" -> ";"
    )

    val serDeInfo: JLinkedMap[String, Any] = linkedMap(
      "serialization_library" -> "org.apache.hadoop.hive.serde2.OpenCSVSerde",
      "parameters"            -> serDeParams
    )

    val storageDescriptor: JLinkedMap[String, Any] = linkedMap(
      "input_format"  -> "org.apache.hadoop.mapred.TextInputFormat",
      "output_format" -> "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat",
      "ser_de_info"   -> serDeInfo
    )

    // ----- schema & contrat (adapte les noms si besoin) -----

    val schema = Schema(
      name = "object_5aeem_prod",
      customProperties = List(
        CustomProperty("type", "glue"),
        CustomProperty("storage_descriptor", storageDescriptor)
      ),
      properties = List(
        Property("ENTETE-CD-EFS",   "string"),
        Property("ENTETE-CD-BOITE", "string"),
        Property("year",  "string", partitioned = true, partitionKeyPosition = Some(1)),
        Property("month", "string", partitioned = true, partitionKeyPosition = Some(2)),
        Property("day",   "string", partitioned = true, partitionKeyPosition = Some(3))
      )
    )

    val contract = DataContract(
      kind       = "DataContract",
      apiVersion = "v3.0.2",
      id         = "ignored",
      status     = "active",
      version    = "1.0.0",
      schema     = List(schema)
    )

    // ----- racine pour SnakeYAML -----

    val root: JLinkedMap[String, Any] = linkedMap(
      "kind"       -> contract.kind,
      "apiVersion" -> contract.apiVersion,
      "id"         -> contract.id,
      "status"     -> contract.status,
      "version"    -> contract.version,
      "schema"     -> toSchemaList(contract.schema)
    )

    // ----- options + dump -----

    val options = new DumperOptions()
    options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK) // block par défaut
    options.setPrettyFlow(true)
    options.setIndent(2)
    options.setWidth(120) // plus la ligne est large, moins il casse les lignes
    options.setDefaultScalarStyle(ScalarStyle.PLAIN) // pas de quotes globales

    val representer = new ContractRepresenter(options)
    val yaml        = new Yaml(representer, options)

    println(yaml.dump(root))
  }
}
