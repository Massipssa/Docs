// src/test/scala/.../DataContractGeneratorSpec.scala
package fr.ccf.job.service.datacontract // <-- adapte le package au tien

import org.mockito.ArgumentMatchers.{any => anyArg, eq => eqTo}
import org.mockito.Mockito.{mock, verify, when, mockConstruction}
import org.scalamock.scalatest.MockFactory
import org.scalatest.PrivateMethodTester
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

import scala.jdk.CollectionConverters._

// ⚠️ Adapte ces imports à tes vrais packages/types
// import fr.ccf.job.service.datacontract.model.{CreStructure, ReferentialPlanning, ColumnProperty, DataContract}
// import fr.ccf.job.service.datacontract.props.CommonProp
// import fr.ccf.job.service.datacontract.mapper.ArtifactColumnTypeMapper

class DataContractGeneratorSpec
    extends AnyWordSpec
    with Matchers
    with MockFactory
    with PrivateMethodTester {

  "generateDataContract" should {

    "return yaml content and call generator with expected args" in {
      // GIVEN
      implicit val jobConfigDto: JobConfigDto = mock(classOf[JobConfigDto])

      val objectId = "CRE_ABC"
      val referentialPlanning = mock(classOf[ReferentialPlanning])
      val latestCreStructure  = mock(classOf[CreStructure])

      when(latestCreStructure.version).thenReturn("1.0.0")

      // Mock CommonProp object call
      val commonProp = mock(classOf[CommonProp])
      when(commonProp.name).thenReturn("myName")
      when(commonProp.objectName).thenReturn("myObjectName")

      // storageDescMap type = adapte si nécessaire (Map[String, StorageDesc] etc.)
      val storageDescMap = mock(classOf[scala.collection.immutable.Map[_, _]])
      when(commonProp.storageDescMap).thenReturn(storageDescMap.asInstanceOf[commonProp.storageDescMap.type])

      mockObject(CommonProp)
      (CommonProp.createCommonProps _)
        .expects(jobConfigDto, "1.0.0", objectId)
        .returning(commonProp)

      // Mock ArtifactColumnTypeMapper call
      // columnsTypes type = adapte si nécessaire
      val columnsTypes = mock(classOf[AnyRef])

      mockObject(ArtifactColumnTypeMapper)
      (ArtifactColumnTypeMapper.createCreColumnsTypesMap _)
        .expects(latestCreStructure)
        .returning(columnsTypes)

      // Compute expected partitionCols using the private method
      val createPartitionsCol = PrivateMethod[List[ColumnProperty]](Symbol("createPartitionsCol"))
      val expectedPartitionCols =
        DataContractGenerator.invokePrivate(createPartitionsCol(referentialPlanning))

      // Mock the DataContractGeneratorImpl created with `new`
      val expectedYaml = "yaml: content"
      val dataContract = mock(classOf[DataContract])

      val construction = mockConstruction(
        classOf[DataContractGeneratorImpl],
        (gen: DataContractGeneratorImpl, _: org.mockito.MockedConstruction.Context) => {
          // stub createDataContract + generate
          when(gen.createDataContract(
            eqTo("myObjectName"),
            anyArg(),            // storageDescMap (type exacte selon ton code)
            eqTo(columnsTypes),  // columnsTypes
            eqTo(expectedPartitionCols)
          )).thenReturn(dataContract)

          when(gen.generate(eqTo(dataContract))).thenReturn(expectedYaml)
        }
      )

      try {
        // WHEN
        val yaml =
          DataContractGenerator.generateDataContract(objectId, referentialPlanning, latestCreStructure)

        // THEN
        yaml shouldBe expectedYaml

        val created = construction.constructed().asScala.head
        verify(created).generate(eqTo(dataContract))
      } finally {
        construction.close()
      }
    }

    "throw IllegalArgumentException when objectId is empty" in {
      implicit val jobConfigDto: JobConfigDto = mock(classOf[JobConfigDto])
      val referentialPlanning = mock(classOf[ReferentialPlanning])
      val latestCreStructure  = mock(classOf[CreStructure])

      val ex = intercept[IllegalArgumentException] {
        DataContractGenerator.generateDataContract("", referentialPlanning, latestCreStructure)
      }
      ex.getMessage should include ("creId should not be empty")
    }

    "rethrow exception when generator.generate fails" in {
      // GIVEN
      implicit val jobConfigDto: JobConfigDto = mock(classOf[JobConfigDto])

      val objectId = "CRE_ABC"
      val referentialPlanning = mock(classOf[ReferentialPlanning])
      val latestCreStructure  = mock(classOf[CreStructure])
      when(latestCreStructure.version).thenReturn("1.0.0")

      val commonProp = mock(classOf[CommonProp])
      when(commonProp.objectName).thenReturn("myObjectName")
      val storageDescMap = mock(classOf[scala.collection.immutable.Map[_, _]])
      when(commonProp.storageDescMap).thenReturn(storageDescMap.asInstanceOf[commonProp.storageDescMap.type])

      mockObject(CommonProp)
      (CommonProp.createCommonProps _)
        .expects(jobConfigDto, "1.0.0", objectId)
        .returning(commonProp)

      val columnsTypes = mock(classOf[AnyRef])
      mockObject(ArtifactColumnTypeMapper)
      (ArtifactColumnTypeMapper.createCreColumnsTypesMap _)
        .expects(latestCreStructure)
        .returning(columnsTypes)

      val createPartitionsCol = PrivateMethod[List[ColumnProperty]](Symbol("createPartitionsCol"))
      val expectedPartitionCols =
        DataContractGenerator.invokePrivate(createPartitionsCol(referentialPlanning))

      val dataContract = mock(classOf[DataContract])

      val boom = new RuntimeException("boom")
      val construction = mockConstruction(
        classOf[DataContractGeneratorImpl],
        (gen: DataContractGeneratorImpl, _: org.mockito.MockedConstruction.Context) => {
          when(gen.createDataContract(
            eqTo("myObjectName"),
            anyArg(),
            eqTo(columnsTypes),
            eqTo(expectedPartitionCols)
          )).thenReturn(dataContract)

          when(gen.generate(eqTo(dataContract))).thenThrow(boom)
        }
      )

      try {
        val ex = intercept[RuntimeException] {
          DataContractGenerator.generateDataContract(objectId, referentialPlanning, latestCreStructure)
        }
        ex shouldBe boom
      } finally {
        construction.close()
      }
    }
  }
}
