#!/bin/bash

set -euo pipefail  # Sécurise le script contre les erreurs

# Transform arguments: ignore empty args and split concatenated arg name and value into separated items
TRANSFORMED_ARGS=()  # ✅ Initialisation correcte du tableau

for ARG in "$@"; do
    [[ -z "$ARG" ]] && continue  # Ignore les arguments vides
    IFS=' ' read -r -a SPLIT_ARG <<< "$ARG"  # Sépare les arguments correctement
    TRANSFORMED_ARGS+=("${SPLIT_ARG[@]}")
done

# Extract target environment from dbt command args
ENV=""

i=0
while [[ $i -lt ${#TRANSFORMED_ARGS[@]} ]]; do
    if [[ "${TRANSFORMED_ARGS[i]}" == "--target" ]] && [[ $((i+1)) -lt ${#TRANSFORMED_ARGS[@]} ]]; then
        ENV="${TRANSFORMED_ARGS[i+1]}"
        break  # ✅ Optimisation : pas besoin de continuer après avoir trouvé "--target"
    fi
    ((i++))
done

SUFFIX=$(echo "$ENV" | tr '[:upper:]' '[:lower:]')  # Convert to lowercase
echo "Target env is ${ENV} (role suffix ${SUFFIX})"

# shellcheck disable=SC2155
export suffix=$(date "+%Y%m%d")
echo "Using suffix: $suffix"

# Assume client principal execute role
if [[ -n "${CLIENT_IAM_ROLE:-}" ]]; then
    echo "Assuming role ${CLIENT_IAM_ROLE}"
    read -r AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN < <(
        aws sts assume-role --role-arn "${CLIENT_IAM_ROLE}" \
        --role-session-name dbt-client \
        --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
        --output text
    )

    export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
fi

# Run dbt
echo "Running dbt with role $(aws sts get-caller-identity | jq -r .Arn) and args '${TRANSFORMED_ARGS[*]}'"
dbt "${TRANSFORMED_ARGS[@]}"
