import org.apache.commons.compress.archivers.tar.{TarArchiveEntry, TarArchiveInputStream}

import java.io._
import java.nio.file.{Files, Path, StandardOpenOption}

def extractTarGz(
  s3Service: S3Service,
  bucket: String,
  inputStream: InputStream,
  outputPrefix: String,
  foldersToExtract: Option[Set[String]] = None
): Unit = {

  val tarIn = new TarArchiveInputStream(new BufferedInputStream(inputStream))

  try {
    var entry: TarArchiveEntry = tarIn.getNextTarEntry

    while (entry != null) {
      val entryName = entry.getName

      val shouldExtract = foldersToExtract match {
        case Some(folders) => folders.exists(folder => entryName.contains(s"$folder/"))
        case None          => true
      }

      // ✅ On extrait uniquement les fichiers (pas les dossiers)
      if (!entry.isDirectory && shouldExtract) {
        val outKey = s"$outputPrefix/$entryName"
        logInfo(s"Extracting: s3://$bucket/$outKey")

        // ✅ write entry content to temp file (streaming, no heap blow)
        val tmp: Path = Files.createTempFile("untar-", ".tmp")
        try {
          val fileOut = new BufferedOutputStream(Files.newOutputStream(tmp, StandardOpenOption.WRITE))

          try {
            val buffer = new Array[Byte](1024 * 1024) // 1MB buffer
            var n = tarIn.read(buffer)
            while (n != -1) {
              fileOut.write(buffer, 0, n)
              n = tarIn.read(buffer)
            }
            fileOut.flush()
          } finally {
            fileOut.close()
          }

          // ✅ upload via existing multipart method
          val inFile = new BufferedInputStream(Files.newInputStream(tmp, StandardOpenOption.READ))
          try {
            s3Service.putMultiPart(bucket, outKey, inFile)
          } finally {
            inFile.close()
          }

        } finally {
          try Files.deleteIfExists(tmp)
          catch { case _: Throwable => () }
        }
      }

      entry = tarIn.getNextTarEntry
    }
  } finally {
    try tarIn.close()
    catch { case _: Throwable => () }
  }
}
