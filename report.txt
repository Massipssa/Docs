import org.scalatest.funsuite.AnyFunSuite
import org.scalatestplus.mockito.MockitoSugar
import org.mockito.Mockito._
import org.mockito.ArgumentMatchers._

class MetadataUtilityTest extends AnyFunSuite with MockitoSugar {

  implicit val jobConfig: JobConfigDto = mock[JobConfigDto]

  test("getParsedMetadataForBatch should return parsed metadata lines") {
    val batchName = "myBatch"
    val appZone = "zone"
    val fileKey = "zone/myBatch/meta.json"
    val expected = Array(MetadataLineDto("line1"), MetadataLineDto("line2"))

    // Mock static-like methods
    mockStaticMethods()

    when(MetadataUtility.getMetadataKeyForBatch(batchName, appZone)).thenReturn(fileKey)
    when(MetadataParser.parseMetadataFile(fileKey)).thenReturn(expected)

    val result = MetadataUtility.getParsedMetadataForBatch(batchName, appZone)
    assert(result.sameElements(expected))
  }

  test("getParsedMetadataForBatch should return empty array when exception is thrown") {
    val batchName = "badBatch"
    val appZone = "zone"

    // Mock static-like methods
    mockStaticMethods()

    when(MetadataUtility.getMetadataKeyForBatch(batchName, appZone))
      .thenThrow(new RuntimeException("not found"))

    val result = MetadataUtility.getParsedMetadataForBatch(batchName, appZone)
    assert(result.isEmpty)
  }

  // This method assumes you're using a mocking framework that allows mocking singletons
  private def mockStaticMethods(): Unit = {
    // Add any necessary setup for mocking MetadataUtility and MetadataParser
    // If using PowerMockito or ScalaMock, implement accordingly
  }
}
