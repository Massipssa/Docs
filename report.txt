val checksToApply = requiredInterfaces
  .select("famille", "position")
  .distinct()
  .as[(String, Int)]
  .collect()
  .toList

val allErrors = checksToApply.flatMap { case (famille, position) =>
  CONFIG_FAMILLE_ATTRIBUTE_REGEXES.get(famille).map { config =>
    val targetCol = s"_c${position - 1}"

    creDf
      .filter(!col(targetCol).rlike(config.regex))
      .select(
        SparkUtility.getRowIndexValue(creDf, hasHeader = false).alias("rowId"),
        lit(targetCol).alias("column"),
        lit(getDescription).alias("description"),
        lit(famille).alias("famille"),
        col(targetCol).alias("actual")
      )
      .collect()
      .map(row =>
        CheckErrorDto(
          Option(row.getAs[Any]("rowId").toString),
          Option(targetCol),
          Option(row.getAs[String]("description")),
          Option(famille),
          Option(s"Expected pattern: ${config.regex}"),
          Option(row.getAs[String]("actual"))
        )
      )
  }.getOrElse(Array.empty)
}.toList
