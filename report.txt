class StorageDescriptorRepresenter(opts: DumperOptions)
  extends StandardRepresenter(opts) {

  // On est dans la section storage_descriptor (property + value)
  private var insideStorageDescriptor: Boolean = false

  // map qui contient: property = "storage_descriptor"
  private def isStorageDescriptorContext(m: JMapBase[_, _]): Boolean =
    m.containsKey("property") &&
      "storage_descriptor" == String.valueOf(m.get("property"))

  // map qui contient: input_format / output_format / ser_de_info
  private def isStorageDescriptorValue(m: JMapBase[_, _]): Boolean =
    m.containsKey("input_format") &&
      m.containsKey("output_format") &&
      m.containsKey("ser_de_info")

  // *** SIGNATURE OK pour snakeyaml 2.4 + StandardRepresenter ***
  override protected def representMapping(
      tag: Tag,
      mapping: JMapBase[_, _],
      flowStyle: DumperOptions.FlowStyle
  ): MappingNode = {

    val prev = insideStorageDescriptor

    // on active le flag dès qu'on entre dans la map avec property=storage_descriptor
    if (prev || isStorageDescriptorContext(mapping)) {
      insideStorageDescriptor = true
    }

    val node = super.representMapping(tag, mapping, flowStyle)

    // seule la VALUE (input_format/output_format/ser_de_info) est en FLOW { ... }
    if (isStorageDescriptorValue(mapping))
      node.setFlowStyle(DumperOptions.FlowStyle.FLOW)
    else
      node.setFlowStyle(DumperOptions.FlowStyle.BLOCK)

    insideStorageDescriptor = prev
    node
  }

  override protected def representScalar(
      tag: Tag,
      value: String,
      style: DumperOptions.ScalarStyle
  ): Node = {
    if (insideStorageDescriptor)
      // Dans storage_descriptor → "..."
      super.representScalar(tag, value, DumperOptions.ScalarStyle.DOUBLE_QUOTED)
    else
      // ailleurs → scalaires simples (sans guillemets)
      super.representScalar(tag, value, DumperOptions.ScalarStyle.PLAIN)
  }
}
