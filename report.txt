package fr.ccf.commons.vault

import com.bettercloud.vault.Vault
import com.bettercloud.vault.VaultConfig
import com.bettercloud.vault.api.Logical
import com.bettercloud.vault.response.LogicalResponse
import com.bettercloud.vault.rest.RestResponse
import org.mockito.ArgumentMatchers.{any, anyInt, eq => eqTo}
import org.mockito.Mockito._
import org.mockito.{MockedConstruction, Mockito}
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

import java.util

class VaultServiceImplSpec extends AnyWordSpec with Matchers {

  /** On évite le vrai login IAM Vault en forçant un token fixe */
  private class VaultServiceTest extends VaultServiceImpl {
    override def getVaultToken(vaultHostname: String, config: VaultConfig, role: Option[String]): String =
      "fake-token"
  }

  "retrieveVaultKeys" should {

    "return credentials map when Vault returns data" in {
      val service = new VaultServiceTest

      val logical = mock(classOf[Logical])
      val response = mock(classOf[LogicalResponse])

      val data = new util.HashMap[String, String]()
      data.put("username", "u1")
      data.put("password", "p1")
      when(response.getData).thenReturn(data)

      when(logical.read(eqTo("secret/data/my-app"))).thenReturn(response)

      val mockedVault: MockedConstruction[Vault] =
        Mockito.mockConstruction(
          classOf[Vault],
          (vaultMock: Vault, _) => {
            // chain: new Vault(...).withRetries(...).logical().read(...)
            when(vaultMock.withRetries(anyInt(), anyInt())).thenReturn(vaultMock)
            when(vaultMock.logical()).thenReturn(logical)
          }
        )

      try {
        val result = service.retrieveVaultKeys(
          vaultHostname = "vault.company.net",
          kvPath = "secret/data/my-app",
          role = None,
          requestTimeout = 5
        )

        result shouldBe Map("username" -> "u1", "password" -> "p1")

        // Vérifs d'appels (optionnelles mais utiles)
        val constructed = mockedVault.constructed()
        constructed.size() shouldBe 1
        verify(constructed.get(0)).withRetries(anyInt(), anyInt())
        verify(logical).read("secret/data/my-app")
      } finally {
        mockedVault.close()
      }
    }

    "throw InvalidCredentialsException when Vault returns empty data" in {
      val service = new VaultServiceTest

      val logical = mock(classOf[Logical])
      val response = mock(classOf[LogicalResponse])
      val rest = mock(classOf[RestResponse])

      when(response.getData).thenReturn(util.Collections.emptyMap[String, String]())
      when(response.getRestResponse).thenReturn(rest)
      when(rest.getStatus).thenReturn(403)

      when(logical.read(eqTo("secret/data/empty"))).thenReturn(response)

      val mockedVault: MockedConstruction[Vault] =
        Mockito.mockConstruction(
          classOf[Vault],
          (vaultMock: Vault, _) => {
            when(vaultMock.withRetries(anyInt(), anyInt())).thenReturn(vaultMock)
            when(vaultMock.logical()).thenReturn(logical)
          }
        )

      try {
        val ex = intercept[InvalidCredentialsException] {
          service.retrieveVaultKeys(
            vaultHostname = "vault.company.net",
            kvPath = "secret/data/empty",
            role = None,
            requestTimeout = 5
          )
        }

        ex.getMessage.toLowerCase should include("empty")
      } finally {
        mockedVault.close()
      }
    }
  }
}
