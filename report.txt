import org.scalatest.funsuite.AnyFunSuite
import org.mockito.Mockito._
import org.mockito.ArgumentMatchers._
import org.scalatestplus.mockito.MockitoSugar
import java.time.{Instant, ZoneId, ZonedDateTime}
import java.time.format.DateTimeFormatter
import com.amazonaws.services.s3.model.S3ObjectSummary

class VacationUtilTest extends AnyFunSuite with MockitoSugar {

  implicit val jobConfig: JobConfigDto = mock[JobConfigDto]

  test("getVacationReceptionTimestamp should return formatted timestamp for valid batch") {
    // Arrange
    val batchName = "test-batch"
    val fakeDate = ZonedDateTime.of(2023, 6, 1, 12, 30, 0, 0, ZoneId.of("Europe/Paris"))
    val instant = fakeDate.toInstant

    val mockSummary = mock[S3ObjectSummary]
    when(mockSummary.getLastModified).thenReturn(java.util.Date.from(instant))

    val fromKey = StorageConstants.FROM_FLOWS_BATCH_KEY_PATTERN.format(batchName)
    when(S3Utils.listAllObjectSummaries(fromKey)).thenReturn(List(mockSummary))

    // Act
    val result = VacationUtil.getVacationReceptionTimestamp(batchName)

    // Assert
    val expectedFormat = DateTimeFormatter.ofPattern(StorageConstants.TIMESTAMP_PATTERN)
    val expectedDateStr = fakeDate.format(expectedFormat)
    assert(result == expectedDateStr)
  }

  test("getVacationReceptionTimestamp should throw exception for null batch name") {
    assertThrows[IllegalArgumentException] {
      VacationUtil.getVacationReceptionTimestamp(null)
    }
  }

  test("getVacationReceptionTimestamp should throw exception for empty batch name") {
    assertThrows[IllegalArgumentException] {
      VacationUtil.getVacationReceptionTimestamp("")
    }
  }
}
