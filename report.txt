package fr.ccf.commons.datacontract

import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec
import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.nodes._

import java.util.{HashMap => JHashMap, Map => JMap}
import scala.jdk.CollectionConverters._

class ContractRepresenterSpec extends AnyWordSpec with Matchers {

  private def jmap(kvs: (Any, Any)*): JMap[Any, Any] = {
    val m = new JHashMap[Any, Any]()
    kvs.foreach { case (k, v) => m.put(k, v) }
    m
  }

  private def asMappingNode(n: Node): MappingNode =
    n shouldBe a[MappingNode]
    n.asInstanceOf[MappingNode]

  private def asScalarNode(n: Node): ScalarNode =
    n shouldBe a[ScalarNode]
    n.asInstanceOf[ScalarNode]

  "ContractRepresenter.representMapping" should {

    "apply custom representation for storage_descriptor map (BLOCK) and render value map in FLOW with double quotes" in {
      val options = new DumperOptions()
      val representer = new ContractRepresenter(options)

      val inner = jmap(
        "bucket" -> "my-bucket",
        "prefix" -> "path/",
        "number" -> Integer.valueOf(12),
        "nested" -> jmap("k1" -> "v1")
      )

      // Map "custom" avec une clé en plus (foo) => doit être ignorée par le custom render
      val mapping = jmap(
        "property" -> "storage_descriptor",
        "value" -> inner,
        "foo" -> "bar"
      )

      val node = representer.representMapping(Tag.MAP, mapping.asInstanceOf[JMap[_, _]], DumperOptions.FlowStyle.BLOCK)
      val top = asMappingNode(node)

      // custom: top level en BLOCK
      top.getFlowStyle shouldBe DumperOptions.FlowStyle.BLOCK

      val tuples = top.getValue.asScala.toList
      // custom: ne garde que property + value (ignore foo)
      tuples.size shouldBe 2

      val t0 = tuples(0)
      val k0 = asScalarNode(t0.getKeyNode)
      val v0 = asScalarNode(t0.getValueNode)

      k0.getValue shouldBe "property"
      k0.getScalarStyle shouldBe DumperOptions.ScalarStyle.PLAIN

      v0.getValue shouldBe "storage_descriptor"
      v0.getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED

      val t1 = tuples(1)
      val k1 = asScalarNode(t1.getKeyNode)
      k1.getValue shouldBe "value"
      k1.getScalarStyle shouldBe DumperOptions.ScalarStyle.PLAIN

      // value => MappingNode FLOW
      val valueNode = asMappingNode(t1.getValueNode)
      valueNode.getFlowStyle shouldBe DumperOptions.FlowStyle.FLOW

      // Dans FLOW: keys et values doivent être DOUBLE_QUOTED
      val innerTuples = valueNode.getValue.asScala.toList
      innerTuples.map(_.getKeyNode).foreach { kn =>
        val sk = asScalarNode(kn)
        sk.getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED
      }

      // bucket -> "my-bucket"
      val bucketTuple = innerTuples.find(t => asScalarNode(t.getKeyNode).getValue == "bucket").get
      asScalarNode(bucketTuple.getValueNode).getValue shouldBe "my-bucket"
      asScalarNode(bucketTuple.getValueNode).getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED

      // number (12) => "12" (stringifié) + quotes
      val numTuple = innerTuples.find(t => asScalarNode(t.getKeyNode).getValue == "number").get
      asScalarNode(numTuple.getValueNode).getValue shouldBe "12"
      asScalarNode(numTuple.getValueNode).getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED

      // nested => MappingNode FLOW récursif
      val nestedTuple = innerTuples.find(t => asScalarNode(t.getKeyNode).getValue == "nested").get
      val nestedNode = asMappingNode(nestedTuple.getValueNode)
      nestedNode.getFlowStyle shouldBe DumperOptions.FlowStyle.FLOW

      val nestedInner = nestedNode.getValue.asScala.toList
      nestedInner.size shouldBe 1
      asScalarNode(nestedInner.head.getKeyNode).getValue shouldBe "k1"
      asScalarNode(nestedInner.head.getKeyNode).getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED
      asScalarNode(nestedInner.head.getValueNode).getValue shouldBe "v1"
      asScalarNode(nestedInner.head.getValueNode).getScalarStyle shouldBe DumperOptions.ScalarStyle.DOUBLE_QUOTED
    }

    "NOT apply custom representation when property != storage_descriptor (keeps all keys)" in {
      val options = new DumperOptions()
      val representer = new ContractRepresenter(options)

      val mapping = jmap(
        "property" -> "other",
        "value" -> jmap("a" -> "b"),
        "foo" -> "bar"
      )

      val node = representer.representMapping(Tag.MAP, mapping.asInstanceOf[JMap[_, _]], DumperOptions.FlowStyle.BLOCK)
      val top = asMappingNode(node)

      // pas de custom: le representer standard doit garder toutes les entrées
      top.getValue.size() shouldBe 3
    }

    "NOT apply custom representation when value is not a map (keeps all keys)" in {
      val options = new DumperOptions()
      val representer = new ContractRepresenter(options)

      val mapping = jmap(
        "property" -> "storage_descriptor",
        "value" -> "not-a-map",
        "foo" -> "bar"
      )

      val node = representer.representMapping(Tag.MAP, mapping.asInstanceOf[JMap[_, _]], DumperOptions.FlowStyle.BLOCK)
      val top = asMappingNode(node)

      // pas de custom: value n'est pas une Map
      top.getValue.size() shouldBe 3
    }
  }
}
