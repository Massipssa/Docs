override def check(
  creDf: DataFrame,
  metadataDf: DataFrame,
  creCsvFilenameDto: CreCsvFilenameDto
)(implicit spark: SparkSession): List[CheckErrorDto] = {

  logger.info(s"Execute ${getCheckName}")

  val creId: String = creCsvFilenameDto.getCreId

  // Skip check for specific CRE ID
  if (creId == "3A001") {
    logger.info(s"Check skipped for CRE ID: $creId")
    return List.empty
  }

  // Extract expected codeBoite from metadata
  val expectedCodeBoiteOpt = metadataDf
    .filter(col("creId") === creId)
    .select("interfaceDto.codeBoite")
    .as[String]
    .headOption

  expectedCodeBoiteOpt match {
    case Some(expectedCodeBoite) =>
      val differencesDf = allValuesAreEqual(creDf, "_c1", expectedCodeBoite)

      if (differencesDf.isEmpty) {
        List.empty
      } else {
        val columnName = CreConstants.DIRECTIVE_COLUMNS_MAP(CreConstants.ENTETE_CD_BTE_COLUMN_INDEX)

        logger.warn(s"CRE: $creId contains different code boite")

        differencesDf
          .select(col("_c1"), col("_c6"))
          .withColumn("index", monotonically_increasing_id())
          .collect()
          .map { row =>
            val index = row.getAs[Long]("index").toString
            val actualValue = row.getAs[String]("_c1")
            val enteteNoColum = row.getAs[String]("_c6")

            CheckErrorDto(
              Option(index),
              Option(enteteNoColum),
              None,
              Option(CreConstants.ENTETE_CD_BTE_COLUMN_NAME),
              Option(s"Expected (codeBoite) in Metadata Interface: $expectedCodeBoite"),
              Option(s"Actual $columnName in CRE: $actualValue")
            )
          }.toList
      }

    case None =>
      logger.warn(s"No metadata found for CRE ID: $creId")
      List.empty
  }
}
