def createMapFromControlVersionDataFrame(
    planIdentifierMap: Map[String, ReferentialPlanningDto],
    controlVersionFileDf: DataFrame
): Map[String, ControlVersionDto] = {

  val versionDfUpdateDateFormatter = DateTimeFormatter.ofPattern(VersioningConstants.UPDATE_DATE_DATE_FORMAT)

  controlVersionFileDf.collect().flatMap { row =>
    val dfRowId = row.getAs[String](ID_COLUMN_CONTROL_VERSION)
    val dfRowVersion = row.getAs[String](VERSION_COLUMN_CONTROL_VERSION)

    try {
      val dfRowMetadataExpectedUpdateDate = Option(row.getAs[String](METADATA_EXPECTED_UPDATE_DATE_CONTROL_VERSION))
        .filterNot(_.isEmpty)
        .map(LocalDate.parse(_, versionDfUpdateDateFormatter))

      val referentialPlanningDto = planIdentifierMap.get(dfRowId)

      val dfRowMetadataExpected: Option[AbstractInterfaceDto] = referentialPlanningDto match {
        case Some(dto) if dto.objectType == CRE_TYPE_PARAM =>
          val rawJson = row.getAs[String](METADATA_EXPECTED_CONTROL_VERSION)
          Some(MetadataParser.parseInterfaceJson(rawJson, handleDoubleQuotes = true))
        case Some(_) =>
          Some(new GesparamControlVersionDto(
            row.getAs[String](METADATA_EXPECTED_CONTROL_VERSION)
              .split(GESPARAM_CONTROL_VERSION_COLUMN_SEPARATOR)
          ))
        case None =>
          logger.warn(s"Could not find Arkea object name $dfRowId in $ARKEA_REFERENTIAL_PLANNING_FILE")
          None
      }

      Some(dfRowId -> new ControlVersionDtoBuilder()
        .insertControlVersionRowDto(ControlVersionRowDto(dfRowId, dfRowVersion, dfRowMetadataExpectedUpdateDate.orNull, dfRowMetadataExpected.orNull))
        .build())

    } catch {
      case ex: Throwable =>
        logger.warn(s"An exception occurred while processing row for $dfRowId in $ARKEA_CONTROL_VERSION_FILE")
        logger.warn(s"${ex.getMessage}")
        None
    }
  }.toMap
}
