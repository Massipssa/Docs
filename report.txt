import React, { createContext, useState, useEffect } from 'react';
import { useQuery } from 'react-query';

// Create the context
export const CreContext = createContext();

// Fetch API data for CRE status
const fetchCreData = async (submittedValues) => {
  const { integrationDate, activityDate, frequency, project } = submittedValues;
  const response = await fetch(
    `your-api-url?integrationDate=${integrationDate}&activityDate=${activityDate}&frequency=${frequency}&project=${project}`
  ); 
  if (!response.ok) {
    throw new Error('Error fetching data');
  }
  return response.json();
};

// Fetch Project data based on CRE
const fetchProjectData = async () => {
  const response = await fetch('your-project-api-url'); // URL to fetch the project data
  if (!response.ok) {
    throw new Error('Error fetching project data');
  }
  return response.json();
};

// Provider component
export const CreProvider = ({ children }) => {
  const defaultSubmittedValues = {
    integrationDate: new Date().toISOString().split('T')[0],
    activityDate: new Date().toISOString().split('T')[0],
    frequency: 'daily',
    project: 'default-project',
  };

  const [submittedValues, setSubmittedValues] = useState(defaultSubmittedValues);

  const [nonCritiqueSize, setNonCritiqueSize] = useState(0);
  const [critiqueSize, setCritiqueSize] = useState(0);
  const [receivedSize, setReceivedSize] = useState(0);
  const [notExpectedSize, setNotExpectedSize] = useState(0);

  const [projects, setProjects] = useState([]); // Store all projects
  const [filteredProjects, setFilteredProjects] = useState([]); // Store filtered projects
  const [filteredCreData, setFilteredCreData] = useState([]); // Store filtered CREs

  const { data, error, isLoading } = useQuery(
    ['creData', submittedValues],
    () => fetchCreData(submittedValues),
    { enabled: !!submittedValues }
  );

  const { data: projectData, error: projectError, isLoading: projectLoading } = useQuery(
    'projectData',
    fetchProjectData // Fetch the project data from the API
  );

  useEffect(() => {
    if (data) {
      const nonCritiques = data.expectedNotCriticalNotReceived || [];
      const critiques = data.expectedCriticalNoReceived || [];
      const received = data.expectedReceive || [];
      const notExpected = data.expectedNotExpected || [];

      setNonCritiqueSize(nonCritiques.length);
      setCritiqueSize(critiques.length);
      setReceivedSize(received.length);
      setNotExpectedSize(notExpected.length);

      setFilteredCreData([...nonCritiques, ...critiques]); // Set both by default
    }

    if (projectData) {
      setProjects(projectData); // Store the project data from API
    }
  }, [data, projectData]);

  // Filter projects and CREs based on Critique CREs
  const filterCritique = () => {
    if (projects && data) {
      const filteredProjects = projects.filter((project) => project.critical.length > 0);
      const filteredCRE = data.expectedCriticalNoReceived || [];
      setFilteredProjects(filteredProjects);
      setFilteredCreData(filteredCRE);
    }
  };

  // Filter projects and CREs based on Non-Critique CREs
  const filterNonCritique = () => {
    if (projects && data) {
      const filteredProjects = projects.filter((project) => project.notCritical.length > 0);
      const filteredCRE = data.expectedNotCriticalNotReceived || [];
      setFilteredProjects(filteredProjects);
      setFilteredCreData(filteredCRE);
    }
  };

  return (
    <CreContext.Provider value={{
      filteredCreData,
      filteredProjects,
      filterCritique,
      filterNonCritique,
      critiqueSize,
      nonCritiqueSize,
      receivedSize,
      notExpectedSize,
      setSubmittedValues,
      isLoading,
      error,
      projectLoading,
      projectError
    }}>
      {children}
    </CreContext.Provider>
  );
};
