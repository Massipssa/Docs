import com.amazonaws.services.s3.AmazonS3
import com.amazonaws.services.s3.model._
import scala.collection.mutable.ListBuffer
import scala.jdk.CollectionConverters._
import scala.util.control.NonFatal
import java.io.{InputStream, ByteArrayInputStream}

def putMultiPart(
    s3Client: AmazonS3,
    bucket: String,
    key: String,
    inputStream: InputStream,
    uploadPartSize: Int
): Unit = {

  val partSize = math.max(uploadPartSize.toLong, 5L * 1024 * 1024) // S3: min 5MB (sauf last part)
  val buffer = new Array[Byte](partSize.toInt)

  // Lis 1ère fois AVANT d'initier le multipart pour éviter multipart "vide"
  var bytesRead = inputStream.read(buffer)

  // stream vide => créer objet vide (ou tu peux choisir de ne rien faire)
  if (bytesRead == -1) {
    val meta = new ObjectMetadata()
    meta.setContentLength(0)
    s3Client.putObject(new PutObjectRequest(bucket, key, new ByteArrayInputStream(Array.emptyByteArray), meta))
    return
  }

  val initRes = s3Client.initiateMultipartUpload(new InitiateMultipartUploadRequest(bucket, key))
  val uploadId = initRes.getUploadId

  val partETags = ListBuffer.empty[PartETag]
  var partNumber = 1

  try {
    while (bytesRead != -1) {
      // IMPORTANT: ne pas réutiliser le buffer brut (il sera réécrit). On crée un stream stable.
      val partStream = new ByteArrayInputStream(buffer, 0, bytesRead)

      val req = new UploadPartRequest()
        .withBucketName(bucket)
        .withKey(key)
        .withUploadId(uploadId)
        .withPartNumber(partNumber)
        .withPartSize(bytesRead.toLong)
        .withInputStream(partStream)

      val res = s3Client.uploadPart(req)
      val etag = res.getPartETag
      if (etag == null || etag.getETag == null) {
        throw new IllegalStateException(s"Missing ETag for part $partNumber on s3://$bucket/$key")
      }

      partETags += etag
      partNumber += 1

      // read next
      bytesRead = inputStream.read(buffer)
    }

    // Safety: ne jamais compléter sans parts
    if (partETags.isEmpty) {
      throw new IllegalStateException(s"No parts uploaded for s3://$bucket/$key (uploadId=$uploadId)")
    }

    val completeReq = new CompleteMultipartUploadRequest(bucket, key, uploadId, partETags.asJava)
    s3Client.completeMultipartUpload(completeReq)

  } catch {
    case NonFatal(e) =>
      // Abort obligatoire pour éviter des multipart "en cours"
      try s3Client.abortMultipartUpload(new AbortMultipartUploadRequest(bucket, key, uploadId))
      catch { case NonFatal(_) => () }
      throw e
  } finally {
    try inputStream.close() catch { case NonFatal(_) => () }
  }
}
